<!DOCTYPE html><html lang="zh"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,minimum-scale=1,user-scalable=no,minimal-ui"><meta name="renderer" content="webkit"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black"><meta name="format-detection" content="telephone=no,email=no,adress=no"><meta name="theme-color" content="#000000"><meta http-equiv="window-target" content="_top"><title>[译] WPF MVVM 循序渐进(从基础到高级) | 不插电码农</title><meta name="description" content="这是一年多前发表在CodeProject上的一篇文章, 讲的是WPF的MVVM框架, 现在来看Windows自家的桌面技术已经没有当初的光环了, 我也是因为最近工作需要, 学习翻阅了很多这方面资料. 觉得MVVM框架的确在一定程度上简化了UI的开发, 对象,模型各司其职. 而这篇文章算是我看到的比较全面的MVVM入门教程, 关于为什么, 怎么样, 如何做的问题都说得很详细. 当然这只是MVVM从入"><meta property="og:type" content="article"><meta property="og:title" content="[译] WPF MVVM 循序渐进(从基础到高级)"><meta property="og:url" content="https://unpluggedcoder.me/2015/11/27/[%E8%AF%91]%20WPF%20MVVM%20%E5%BE%AA%E5%BA%8F%E6%B8%90%E8%BF%9B(%E4%BB%8E%E5%9F%BA%E7%A1%80%E5%88%B0%E9%AB%98%E7%BA%A7)/index.html"><meta property="og:site_name" content="不插电码农"><meta property="og:description" content="这是一年多前发表在CodeProject上的一篇文章, 讲的是WPF的MVVM框架, 现在来看Windows自家的桌面技术已经没有当初的光环了, 我也是因为最近工作需要, 学习翻阅了很多这方面资料. 觉得MVVM框架的确在一定程度上简化了UI的开发, 对象,模型各司其职. 而这篇文章算是我看到的比较全面的MVVM入门教程, 关于为什么, 怎么样, 如何做的问题都说得很详细. 当然这只是MVVM从入"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://www.codeproject.com/KB/WPF/819294/1.png"><meta property="og:image" content="https://www.codeproject.com/KB/WPF/819294/2.png"><meta property="og:image" content="https://www.codeproject.com/KB/WPF/819294/3.png"><meta property="og:image" content="https://www.codeproject.com/KB/WPF/819294/4.png"><meta property="og:image" content="https://www.codeproject.com/KB/WPF/819294/5.png"><meta property="og:image" content="https://www.codeproject.com/KB/WPF/819294/6.png"><meta property="og:image" content="https://www.codeproject.com/KB/WPF/819294/8.png"><meta property="og:image" content="https://www.codeproject.com/KB/WPF/819294/9.png"><meta property="og:image" content="https://www.codeproject.com/KB/WPF/819294/10.png"><meta property="og:image" content="https://www.codeproject.com/KB/WPF/819294/11.png"><meta property="og:image" content="https://www.codeproject.com/KB/WPF/819294/12.png"><meta property="og:image" content="https://www.codeproject.com/KB/WPF/819294/13.png"><meta property="og:image" content="https://www.codeproject.com/KB/WPF/819294/14.png"><meta property="og:image" content="https://www.codeproject.com/KB/WPF/819294/15.png"><meta property="og:image" content="https://www.codeproject.com/KB/WPF/819294/16.png"><meta property="og:image" content="https://www.codeproject.com/KB/WPF/819294/17.png"><meta property="og:image" content="https://www.codeproject.com/KB/WPF/819294/18.png"><meta property="og:image" content="https://www.codeproject.com/KB/WPF/819294/19.png"><meta property="og:image" content="https://www.codeproject.com/KB/WPF/819294/20.png"><meta property="og:image" content="https://www.codeproject.com/KB/WPF/819294/21.png"><meta property="og:image" content="https://www.codeproject.com/KB/WPF/819294/22.png"><meta property="og:image" content="https://www.codeproject.com/KB/WPF/819294/video_2.png"><meta property="article:published_time" content="2015-11-27T03:03:30.000Z"><meta property="article:modified_time" content="2022-09-15T15:51:05.350Z"><meta property="article:author" content="不插电码农"><meta property="article:tag" content="Windows"><meta property="article:tag" content="c#"><meta property="article:tag" content="MVVM"><meta property="article:tag" content="WPF"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://www.codeproject.com/KB/WPF/819294/1.png"><link rel="canonical" href="https://unpluggedcoder.me/2015/11/27/[%E8%AF%91]%20WPF%20MVVM%20%E5%BE%AA%E5%BA%8F%E6%B8%90%E8%BF%9B(%E4%BB%8E%E5%9F%BA%E7%A1%80%E5%88%B0%E9%AB%98%E7%BA%A7)/index.html"><link rel="alternate" href="/atom.xml" title="不插电码农" type="application/atom+xml"><link rel="icon" href="/favicon.png" type="image/x-icon"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/gitment@0.0.3/style/default.min.css"><link href="//cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.3.5/dist/jquery.fancybox.min.css" rel="stylesheet"><meta name="generator" content="Hexo 6.3.0"></head><body class="main-center theme-purple" itemscope itemtype="http://schema.org/WebPage"><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="slimContent"><div class="navbar-header"><div class="profile-block text-center"><a id="avatar" href="https://github.com/unpluggedcoder" target="_blank"><img class="img-circle img-rotate" src="/images/avatar.jpg" width="200" height="200"></a><h2 id="name" class="hidden-xs hidden-sm">不插电码农</h2><h3 id="title" class="hidden-xs hidden-sm hidden-md">A coder, love sketch and drumming.</h3><small id="location" class="text-muted hidden-xs hidden-sm"><i class="icon icon-map-marker"></i> Inside the GreatWall</small></div><div class="search" id="search-form-wrap"><form class="search-form sidebar-form"><div class="input-group"><input type="text" class="search-form-input form-control" placeholder="搜索"> <span class="input-group-btn"><button type="submit" class="search-form-submit btn btn-flat" onclick="return!1"><i class="icon icon-search"></i></button></span></div></form><div class="ins-search"><div class="ins-search-mask"></div><div class="ins-search-container"><div class="ins-input-wrapper"><input type="text" class="ins-search-input" placeholder="想要查找什么..." x-webkit-speech> <button type="button" class="close ins-close ins-selectable" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">×</span></button></div><div class="ins-section-wrapper"><div class="ins-section-container"></div></div></div></div></div><button class="navbar-toggle collapsed" type="button" data-toggle="collapse" data-target="#main-navbar" aria-controls="main-navbar" aria-expanded="false"><span class="sr-only">Toggle navigation</span> <span class="icon-bar"></span> <span class="icon-bar"></span> <span class="icon-bar"></span></button></div><nav id="main-navbar" class="collapse navbar-collapse" itemscope itemtype="http://schema.org/SiteNavigationElement" role="navigation"><ul class="nav navbar-nav main-nav menu-highlight"><li class="menu-item menu-item-home"><a href="/."><i class="icon icon-home-fill"></i> <span class="menu-title">首页</span></a></li><li class="menu-item menu-item-archives"><a href="/archives"><i class="icon icon-archives-fill"></i> <span class="menu-title">归档</span></a></li><li class="menu-item menu-item-categories"><a href="/categories"><i class="icon icon-folder"></i> <span class="menu-title">分类</span></a></li><li class="menu-item menu-item-tags"><a href="/tags"><i class="icon icon-tags"></i> <span class="menu-title">标签</span></a></li><li class="menu-item menu-item-repository"><a href="/repository"><i class="icon icon-project"></i> <span class="menu-title">项目</span></a></li><li class="menu-item menu-item-about"><a href="/about"><i class="icon icon-cup-fill"></i> <span class="menu-title">关于</span></a></li></ul><ul class="social-links"><li><a href="https://github.com/unpluggedcoder" target="_blank" title="Github" data-toggle="tooltip" data-placement="top"><i class="icon icon-github"></i></a></li><li><a href="https://twitter.com/unpluggedcoder" target="_blank" title="Twitter" data-toggle="tooltip" data-placement="top"><i class="icon icon-twitter"></i></a></li><li><a href="/atom.xml" target="_blank" title="Rss" data-toggle="tooltip" data-placement="top"><i class="icon icon-rss"></i></a></li></ul></nav></div></header><aside class="sidebar" itemscope itemtype="http://schema.org/WPSideBar"><div class="slimContent"><div class="widget"><h3 class="widget-title">公告</h3><div class="widget-body"><div id="board"><div class="content"><p>Nothing changes until you do.</p></div></div></div></div><div class="widget"><h3 class="widget-title">分类</h3><div class="widget-body"><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/AWS/">AWS</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/C-C/">C/C++</a><span class="category-list-count">22</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/C-C/%E6%9D%82%E9%A1%B9/">杂项</a><span class="category-list-count">1</span></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/DrumCover/">DrumCover</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Python/">Python</a><span class="category-list-count">6</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Rust/">Rust</a><span class="category-list-count">19</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/Rust/Flamegraph/">Flamegraph</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Rust/%E5%85%A5%E9%97%A8%E5%A4%B1%E8%B4%A5/">入门失败</a><span class="category-list-count">17</span></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/Unix-Linux/">Unix/Linux</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Windows/">Windows</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E4%B9%A6/">书</a><span class="category-list-count">13</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%95%B0%E6%8D%AE%E7%9B%B8%E5%85%B3/">数据相关</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%9D%82%E9%A1%B9/">杂项</a><span class="category-list-count">7</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%B6%82%E9%B8%A6/">涂鸦</a><span class="category-list-count">6</span></li></ul></div></div><div class="widget"><h3 class="widget-title">归档</h3><div class="widget-body"><ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/">2021</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/">2020</a><span class="archive-list-count">14</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/">2019</a><span class="archive-list-count">20</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/">2018</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/">2017</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/">2016</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/">2015</a><span class="archive-list-count">7</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/">2014</a><span class="archive-list-count">16</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/">2013</a><span class="archive-list-count">14</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2012/">2012</a><span class="archive-list-count">2</span></li></ul></div></div><div class="widget"><h3 class="widget-title">最新文章</h3><div class="widget-body"><ul class="recent-post-list list-unstyled"><li><div class="item-thumb"><a href="/2021/05/22/Improved%20Differential%20Flame%20Graph/" class="thumb"><span class="thumb-image thumb-none"></span></a></div><div class="item-inner"><p class="item-category"><a class="category-link" href="/categories/Rust/">Rust</a><i class="icon icon-angle-right"></i><a class="category-link" href="/categories/Rust/Flamegraph/">Flamegraph</a></p><p class="item-title"><a href="/2021/05/22/Improved%20Differential%20Flame%20Graph/" class="title">Improved Differential Flame Graph</a></p><p class="item-date"><time datetime="2021-05-22T00:29:20.000Z" itemprop="datePublished">2021-05-22</time></p></div></li><li><div class="item-thumb"><a href="/2020/05/31/2020-04%E4%B9%A6%E5%8D%95/" class="thumb"><span class="thumb-image thumb-none"></span></a></div><div class="item-inner"><p class="item-category"><a class="category-link" href="/categories/%E4%B9%A6/">书</a></p><p class="item-title"><a href="/2020/05/31/2020-04%E4%B9%A6%E5%8D%95/" class="title">2020-04书单</a></p><p class="item-date"><time datetime="2020-05-31T13:44:20.000Z" itemprop="datePublished">2020-05-31</time></p></div></li><li><div class="item-thumb"><a href="/2020/04/20/%E7%81%B0%E7%8A%80%E7%89%9B/" class="thumb"><span style="background-image:url(/images/s29399691.jpg)" alt="The Gray Rhino" class="thumb-image"></span></a></div><div class="item-inner"><p class="item-category"><a class="category-link" href="/categories/%E4%B9%A6/">书</a></p><p class="item-title"><a href="/2020/04/20/%E7%81%B0%E7%8A%80%E7%89%9B/" class="title">The Gray Rhino</a></p><p class="item-date"><time datetime="2020-04-20T15:44:20.000Z" itemprop="datePublished">2020-04-20</time></p></div></li><li><div class="item-thumb"><a href="/2020/04/20/Algorithms%20Illuminated,%20Part%201/" class="thumb"><span style="background-image:url(/images/s29970325.jpg)" alt="算法详解（卷1）—算法基础" class="thumb-image"></span></a></div><div class="item-inner"><p class="item-category"><a class="category-link" href="/categories/%E4%B9%A6/">书</a></p><p class="item-title"><a href="/2020/04/20/Algorithms%20Illuminated,%20Part%201/" class="title">算法详解（卷1）—算法基础</a></p><p class="item-date"><time datetime="2020-04-20T15:40:20.000Z" itemprop="datePublished">2020-04-20</time></p></div></li><li><div class="item-thumb"><a href="/2020/04/20/RustHighPerformance/" class="thumb"><span style="background-image:url(/images/b08822.png)" alt="Rust High Performance" class="thumb-image"></span></a></div><div class="item-inner"><p class="item-category"><a class="category-link" href="/categories/%E4%B9%A6/">书</a></p><p class="item-title"><a href="/2020/04/20/RustHighPerformance/" class="title">Rust High Performance</a></p><p class="item-date"><time datetime="2020-04-20T14:46:20.000Z" itemprop="datePublished">2020-04-20</time></p></div></li></ul></div></div></div></aside><main class="main" role="main"><div class="content"><article id="post-[译] WPF MVVM 循序渐进(从基础到高级)" class="article article-type-post" itemscope itemtype="http://schema.org/BlogPosting"><div class="article-header"><h1 class="article-title" itemprop="name">[译] WPF MVVM 循序渐进(从基础到高级)</h1><div class="article-meta"><span class="article-date"><i class="icon icon-calendar-check"></i> <a href="/2015/11/27/%5B%E8%AF%91%5D%20WPF%20MVVM%20%E5%BE%AA%E5%BA%8F%E6%B8%90%E8%BF%9B(%E4%BB%8E%E5%9F%BA%E7%A1%80%E5%88%B0%E9%AB%98%E7%BA%A7)/" class="article-date"><time datetime="2015-11-27T03:03:30.000Z" itemprop="datePublished">2015-11-27</time> </a></span><span class="article-category"><i class="icon icon-folder"></i> <a class="article-category-link" href="/categories/Windows/">Windows</a> </span><span class="article-tag"><i class="icon icon-tags"></i> <a class="article-tag-link-link" href="/tags/MVVM/" rel="tag">MVVM</a>, <a class="article-tag-link-link" href="/tags/WPF/" rel="tag">WPF</a>, <a class="article-tag-link-link" href="/tags/Windows/" rel="tag">Windows</a>, <a class="article-tag-link-link" href="/tags/c/" rel="tag">c#</a> </span><span class="article-read hidden-xs"><i class="icon icon-eye-fill" aria-hidden="true"></i> <span id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span> </span></span><span class="post-comment"><i class="icon icon-comment"></i> <a href="/2015/11/27/%5B%E8%AF%91%5D%20WPF%20MVVM%20%E5%BE%AA%E5%BA%8F%E6%B8%90%E8%BF%9B(%E4%BB%8E%E5%9F%BA%E7%A1%80%E5%88%B0%E9%AB%98%E7%BA%A7)/#comments" class="article-comment-link">评论</a></span> <span class="post-wordcount hidden-xs" itemprop="wordCount">字数统计: 5.6k(字)</span> <span class="post-readcount hidden-xs" itemprop="timeRequired">阅读时长: 22(分)</span></div></div><div class="article-entry marked-body" itemprop="articleBody"><p>这是一年多前发表在CodeProject上的一篇文章, 讲的是WPF的MVVM框架, 现在来看Windows自家的桌面技术已经没有当初的光环了, 我也是因为最近工作需要, 学习翻阅了很多这方面资料. 觉得MVVM框架的确在一定程度上简化了UI的开发, 对象,模型各司其职. 而这篇文章算是我看到的比较全面的MVVM入门教程, 关于为什么, 怎么样, 如何做的问题都说得很详细. 当然这只是MVVM从入门到高级的文章, 关于更多的MVVM高级的技巧在文章最后有几个延伸阅读, 有这方面需求的同学可看看.</p><p>本文翻译自Shivprasad koirala在CodeProject上的文章:<a target="_blank" rel="noopener" href="https://www.codeproject.com/Articles/819294/WPF-MVVM-step-by-step-Basics-to-Advance-Level">WPF MVVM step by step (Basics to Advance Level)</a></p><p>[TOC]</p><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>从我们还是儿童到学习成长为成年人， 生命一直都在演变。 对于软件架构， 同样适用这个道理， 从一个基础的架构开始， 随着每个需求和情境在不断演化。</p><p>如果你问任何一个.NET开发者， 什么是最小的基础架构， 首先浮现的就是”三层架构”。 在这个框架中， 我们把项目分为三个逻辑层次: UI层， 业务逻辑层和数据访问层， 每一层都负责各自对应的功能。</p><p><img src="https://www.codeproject.com/KB/WPF/819294/1.png" alt="三层架构"></p><p>UI负责显示功能， 业务逻辑层负责校验， 数据访问层负责SQL语句。 3层架构有如下的好处:</p><ul><li>包容变化: 每一层的变化不会重复跨越到其它层次。</li><li>重用性: 增强可重用性， 因为每一层都是分离， 自包容的独立实体<br>MVVM是三层架构的一个演化。 我知道我没有一个历史去证明这点， 但是我个人对MVVM进行了演化和观察。 那我们先从三层基础架构开始， 去理解三层架构存在的问题， 看MVVM架构是如何解决这些问题， 然后升级到去创建一个自定义的MVVM框架代码。 下面是本文接下来的路线图。</li></ul><p><img src="https://www.codeproject.com/KB/WPF/819294/2.png" alt="Road map of MVVM"></p><h3 id="简单的三层架构示例和GLUE-胶水-代码问题"><a href="#简单的三层架构示例和GLUE-胶水-代码问题" class="headerlink" title="简单的三层架构示例和GLUE(胶水)代码问题"></a>简单的三层架构示例和GLUE(胶水)代码问题</h3><p>首先， 让我们来理解三层架构以及它存在的问题， 然后看MVVM如何解决这个问题。</p><p>直觉和现实是两种不同的事物。 当你看到三层架构的图， 你首先的直觉是每个功能可能都分布在各自层次。 但是当你实际编写代码时， 有些层次被强迫去做一些它们不应该做的<strong>额外的工作</strong>(破坏了SOLID原则)。 如果你对SOLID原则还不熟悉可以参考这个视频: <a target="_blank" rel="noopener" href="https://www.facebook.com/photo.php?v=690253231015623&amp;set=vb.341019362605680&amp;type=2&amp;theater">SOLID principle video</a>(译者注: <a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/SOLID_%28%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1%29">SOLID</a>指Single responsibility， Open-closed， Liskov substitution， Interface segregation and Dependency inversion， 即单一功能、开闭原则、里氏替换、接口隔离以及依赖反转)。</p><p><img src="https://www.codeproject.com/KB/WPF/819294/3.png" alt="GLUE Code"></p><p>这部分额外工作就在UI与Model之间， 以及Model与Data access之间。 我们把这类代码称为”GLUE”(胶水， 译者注:由于作者全用大写字母表示， 因此后续延用GLUE)代码。 “GLUE”代码主要有两种逻辑类型:<br>鄙人浅见薄识， 如果你有更多的”GLUE”类型实例， 请在留言中指出。</p><ul><li>映射逻辑(绑定逻辑): 每一层通过属性、方法和集合和其它层链接。例如， 一个在UI层中名为“txtCustomerName”的Textbox控件，将其映射到customer类的”CustomerName”属性。</li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">txtCustomerName.text = custobj.CustomerName;  <span class="comment">// 映射代码</span></span><br></pre></td></tr></table></figure><p>现在谁应该拥有上述绑定逻辑代码，UI还是Model？开发者往往把这个代码推到UI层次中。</p><ul><li>转换逻辑：每个层次使用的数据格式都是不同的。比如一个Model类”Person”有一个性别属性，可取值分别为”F”(Female)和”M”(Male)分别代表女性和男性。但是在UI层中，希望将这个值可视化为一个复选框控件，勾选则代表男性，不勾选则代表女性。下面是一个转换代码示例。</li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (obj.Gender == “M”) <span class="comment">// 转换代码</span></span><br><span class="line">&#123;</span><br><span class="line">    chkMale.IsChecked = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    chkMale.IsChecked = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>大多数开发者最终会将”GLUE”代码写到UI层中。通常可以在后台代码中定位到这类代码，例如.cs文件。如果UI是XAML，则对应的XAML.cs包含GLUE代码；如果UI是ASPX，则对应的ASPX.cs包含GLUE代码，以此类推。</p><p>那么问题来了：是UI负责这类GLUE代码吗？让我们看下WPF应用中的一个简单的三层结构例子，以及更详细的GLUE代码细节。</p><p>下面是一个简单的模型类”Customer”，它有三个属性“CustomerName”, “Amount” 和“Married” 。</p><p><img src="https://www.codeproject.com/KB/WPF/819294/4.png" alt="Customer class"></p><p>但是，当这个模型显示到UI上时它又表现如下。所以，你可以看出来它包含了该模型的所有属性，以及一些额外的元素：颜色标签和Married复选框控件。</p><p><img src="https://www.codeproject.com/KB/WPF/819294/5.png" alt="Customer UI"></p><p>下面有一张简单的表，左边是Model，右边是UI，中间是谈过的映射和转换逻辑。</p><p>你可以看到前两行没有转换逻辑，只有映射逻辑，另外两行则同时包含转换逻辑和映射逻辑。</p><table><thead><tr><th>Model</th><th>GLUE CODE</th><th>UI</th></tr></thead><tbody><tr><td>Customer Name</td><td>No conversion needed only Mapping</td><td>Customer Name</td></tr><tr><td>Amount</td><td>No conversion needed only Mapping</td><td>Amount</td></tr><tr><td>Amount</td><td>Mapping + Conversion logic.</td><td>&gt; 1500 &#x3D; BLUE, &lt; 1500 &#x3D; RED</td></tr><tr><td>Married</td><td>Mapping + Conversion logic.</td><td>True – Married, False - UnMarried</td></tr></tbody></table><p>这些转换和映射逻辑代码通常会在“xaml.cs”文件中。下面是上图对应的后台代码，你可以看到映射代码和颜色判定、性别格式转换代码。我在代码中用注释标注出来，这样你可以看到哪些是映射代码，哪些是转换代码。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">lblName.Content = o.CustomerName; <span class="comment">// 映射代码</span></span><br><span class="line">lblAmount.Content = o.Amount; <span class="comment">// 映射代码</span></span><br><span class="line"><span class="keyword">if</span> (o.Amount &gt; <span class="number">2000</span>) <span class="comment">// 转换代码</span></span><br><span class="line">&#123;</span><br><span class="line">    lblBuyingHabits.Background = <span class="keyword">new</span> SolidColorBrush(Colors.Blue);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (o.Amount &gt; <span class="number">1500</span>) <span class="comment">// 转换代码</span></span><br><span class="line">&#123;</span><br><span class="line">    lblBuyingHabits.Background = <span class="keyword">new</span> SolidColorBrush(Colors.Red);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (obj.Married == “Married”) <span class="comment">// 转换代码</span></span><br><span class="line">&#123;</span><br><span class="line">    chkMarried.IsChecked = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    chkMarried.IsChecked = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在这些GLUE代码存在的问题：</p><ul><li><strong>单一责任原则被破坏（SRPViolation）</strong>： 是UI负责这些GLUE代码吗？这种情况下改变了Amount数量，同时也需要修改UI代码。现在，数据的改变为什么会让我去修改UI的代码？这里可以闻到坏代码的味道。UI应该只在我修改样式，颜色和布局的时候才改变。</li><li><strong>重用性</strong>： 如果我想把同样的颜色逻辑和性别格式转换用到下面的编辑界面，我该怎么做？拷贝粘帖重复的代码？<br><img src="https://www.codeproject.com/KB/WPF/819294/6.png" alt="CustomerEdit"></li></ul><p>如果我想走得更远一点，把这个GLUE代码用在不同的UI技术体系上，比如MVC、Windows Form或者Mobile应用上。</p><pre><code>![Reusability](https://www.codeproject.com/KB/WPF/819294/7.png)
</code></pre><p>但是这里跨UI技术平台的重用实际上是不可能的，因为每个平台UI背后都和各自的UI技术体系耦合得很紧密。</p><p>比如，下面的后台代码是继承自“Windows”类，而“Windows”类是集成在WPF UI体系中。如果我们想在Web应用或者MVC中应用这些逻辑，却又无法去创建一个这样的类对象来使用。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">MainWindow : Window</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Behind code is here</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么我们要怎么重用后台代码？怎么遵循SRP原则？</p><h3 id="第一步：最简单的MVVM示例-把后台代码移到类中"><a href="#第一步：最简单的MVVM示例-把后台代码移到类中" class="headerlink" title="第一步：最简单的MVVM示例 - 把后台代码移到类中"></a>第一步：最简单的MVVM示例 - 把后台代码移到类中</h3><p>我想大部分开发者已经知道怎么解决这个问题。毫无疑问地把后台代码（GLUE代码）移到一个类库中。这个类库代表了描述了UI的属性和行为。任何移入到这个类库的代码都可以编译成DLL，然后被所有.NET项目（Windows, Web等等）所引用。 因此，在这一节我们将创建一个最简单的MVVM示例，然后在后续的章节中我们将基于这个示例创建更高级的MVVM示例。</p><p><img src="https://www.codeproject.com/KB/WPF/819294/8.png" alt="Simplest MVVM"></p><p>我们创建一个“CustomerViewModel”类来包含GLUE代码。“CustomerViewModel”类代表了你的UI，所以我们想保持它的属性和UI命名约定一致。你可以从下图看出来“CustomerViewModel”类的属性是如何从之前的CustomerModel类中映射过来: “TxtCustomerName”对应“CustomerName”，“TxtAmount”对应“Amount”等等。</p><p><img src="https://www.codeproject.com/KB/WPF/819294/9.png" alt="ViewModel"></p><p>下面是实际代码：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">CustomerViewModel</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> Customer obj = <span class="keyword">new</span> Customer();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> TxtCustomerName</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123; <span class="keyword">return</span> obj.CustomerName; &#125;</span><br><span class="line">        <span class="keyword">set</span> &#123; obj.CustomerName = <span class="keyword">value</span>; &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> TxtAmount</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123; <span class="keyword">return</span> Convert.ToString(obj.Amount) ; &#125;</span><br><span class="line">        <span class="keyword">set</span> &#123; obj.Amount = Convert.ToDouble(<span class="keyword">value</span>); &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> LblAmountColor</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (obj.Amount &gt; <span class="number">2000</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&quot;Blue&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (obj.Amount &gt; <span class="number">1500</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&quot;Red&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;Yellow&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">bool</span> IsMarried</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (obj.Married == <span class="string">&quot;Married&quot;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于“CustomerViewModel”这个类有以下几点注意：</p><ul><li>类属性都以UI的命名方式来约定，这样看上去会更形象一些；</li><li>这个类负责了类型转换的代码，使得UI看上去更轻量级。例如代码中的“TxtAmount”属性。在Model类中的“Amount”属性是数字，而转换的过程是在ViewModel类中完成。换句话说这个类负责了UI显示的所有职责（译者注：逻辑上的业务职责）让UI后台代码看上去更简洁；</li><li>所有转换逻辑的代码都在这个类中，例如“LblAmountColor”属性和“IsMarried”属性；</li><li>所有的属性数据都保持了简单的字符类型，这样可以在大多UI技术平台上适用。例如，“LblAmountColor”属性把颜色值用字符串来传递，这样可以在任何UI类型中重用，同时我们也保持了最小的数据共性。</li></ul><p>现在“CustomerViewModel”类包含了所有的后台代码逻辑，我们可以创建这个类的对象并绑定到UI元素上。你可以在下面代码看到我们只剩下了映射逻辑的代码部分，而转换逻辑的”GLUE”代码已经没有了。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">DisplayUi</span>(<span class="params">CustomerViewModel o</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    lblName.Content = o.TxtCustomerName;</span><br><span class="line">    lblAmount.Content = o.TxtAmount;</span><br><span class="line">    BrushConverter brushconv = <span class="keyword">new</span> BrushConverter();</span><br><span class="line">    lblBuyingHabits.Background = brushconv.ConvertFromString(o.LblAmountColor) <span class="keyword">as</span> SolidColorBrush;</span><br><span class="line">    chkMarried.IsChecked = o.IsMarried;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="第二步：添加绑定-消灭后台代码"><a href="#第二步：添加绑定-消灭后台代码" class="headerlink" title="第二步：添加绑定 - 消灭后台代码"></a>第二步：添加绑定 - 消灭后台代码</h3><p>第一步的方法很好，但是我们知道后台代码仍然还有问题，在WPF中消灭所有后台代码是完全可能的。接下来WPF绑定和命令登场了。</p><p>WPF以其绑定（Binding）、命令（Commands）和声明式编程（Declarative programming）而著称。声明式编程意味着你可以使用XMAL来表达你的C#代码，而不用编写完整的C#代码。绑定功能帮助一个WPF对象连接到其它的WPF对象，从而他们可以发送和接收数据。</p><p>当前的映射C#代码有三个步骤：</p><ul><li><strong>导入</strong>： 我们要做的第一件事情是导入“CustomerViewModel”名称空间。</li><li><strong>创建对象</strong>： 下一步要创建“CustomerViewModel”类的对象。</li><li><strong>绑定代码</strong>： 最后将WPF UI绑定到这个ViewModel对象。</li></ul><p>下面表格展示了C#代码和与其对应相同的WPF XAML代码。</p><table><thead><tr><th>步骤</th><th>C#代码</th><th>XAML代码</th></tr></thead><tbody><tr><td>导入</td><td>using CustomerViewModel;</td><td>xmlns:custns&#x3D;”clr-namespace:CustomerViewModel;assembly&#x3D;CustomerViewModel”</td></tr><tr><td>创建对象</td><td>CustomerViewModelobj &#x3D; new CustomerViewModel(); obj.CustomerName &#x3D; “Shiv”; obj.Amount &#x3D; 2000; obj.Married &#x3D; “Married”;</td><td>&lt; Window.Resources&gt; &lt; custns: CustomerViewModel x:Key&#x3D;”custviewobj” TxtCustomerName&#x3D;”Shiv” TxtAmount&#x3D;”1000” IsMarried&#x3D;”true”&#x2F;&gt;</td></tr><tr><td>绑定对象</td><td>lblName.Content &#x3D; o.CustomerName;</td><td>&lt; Label x:Name&#x3D;”lblName” Content&#x3D;”{Binding TxtCustomerName, Source&#x3D;{StaticResourcecustviewobj}}”&#x2F;&gt;</td></tr></tbody></table><p>你不需要写后台的代码，我们可以选中UI元素，按F4，如下图中选择指定绑定。这个步骤会把绑定代码插入到XAML中。</p><p><img src="https://www.codeproject.com/KB/WPF/819294/10.png" alt="Create Binding1"></p><p>选择“StaticResource”来指定映射，然后在UI元素和ViewModel对象之间指定绑定路径。</p><p><img src="https://www.codeproject.com/KB/WPF/819294/11.png" alt="Create Binding2"></p><p>这是你查看XAML.CS文件，它已经没有任何GLUE代码，同样也没有转换和映射代码。唯一的代码就是标准的WPF UI初始化代码。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">partial</span> <span class="keyword">class</span> <span class="title">MVVMWithBindings</span> : <span class="title">Window</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MVVMWithBindings</span>()</span></span><br><span class="line">    &#123;InitializeComponent();&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="第三步：添加执行动作和“INotifyPropertyChanged”接口"><a href="#第三步：添加执行动作和“INotifyPropertyChanged”接口" class="headerlink" title="第三步：添加执行动作和“INotifyPropertyChanged”接口"></a>第三步：添加执行动作和“INotifyPropertyChanged”接口</h3><p>应用程序不仅仅只是有textboxs 和 labels， 同样还需要执行动作，比如按钮，鼠标事件等。 因此让我们添加一个按钮来看看如何把MVVM类应用起来。 我们在同样的UI上添加了一个‘Calculate tax’按钮，当用户按下按钮，它将根据“Sales Amount”值计算出税值并显示在界面上。</p><p><img src="https://www.codeproject.com/KB/WPF/819294/12.png" alt="Add Action"></p><p>因此为了在Model类实现上面的功能，我们添加一个“CalculateTax()”方法。当这个方法被执行，它根据薪水范围计算出税值，并将值保存在“Tax”属性值中。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Customer</span></span><br><span class="line">&#123;</span><br><span class="line">    ....</span><br><span class="line">    ....</span><br><span class="line">    ....</span><br><span class="line">    ....</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">double</span> _Tax;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">double</span> Tax</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123; <span class="keyword">return</span> _Tax; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">CalculateTax</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (_Amount &gt; <span class="number">2000</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            _Tax = <span class="number">20</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (_Amount &gt; <span class="number">1000</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            _Tax = <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            _Tax = <span class="number">5</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于ViewModel类是Model类的一个封装，因此我们需要在ViewModel类中创建一个方法来调用Model的“CalculateTax”方法。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">CustomerViewModel</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> Customer obj = <span class="keyword">new</span> Customer();</span><br><span class="line">    ....</span><br><span class="line">    ....</span><br><span class="line">    ....</span><br><span class="line">    ....</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Calculate</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        obj.CalculateTax();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在，我们想要在XAML的视图中调用这个“Calculate”方法，而不是在后台编写。不过你不能直接通过XAML调用“Calculate”方法，你需要用WPF的command类。</p><p>我们通过使用绑定属性将数据发送给ViewModel类，而发送执行动作给ViewModel类则需要使用命令。</p><p><img src="https://www.codeproject.com/KB/WPF/819294/13.png" alt="Action and Properties"></p><p>所有从视图元素产生的动作都发送给command类，所以第一步是创建一个command类。为了创建自定义的command类，我们需要实现”ICommand”接口（如下图）。</p><p>“ICommand”接口有两个必须要重载的方法：“CanExecute” 和 “Execute”。在“Execute”中我们放的是希望动作发生时实际执行的逻辑代码（比如按钮按下，右键按下等）。在“CanExecute”中我们放的是验证逻辑来决定“Execute”代码是否应该执行。</p><p><img src="https://www.codeproject.com/KB/WPF/819294/14.png" alt="ICommand"></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ButtonCommand</span> : <span class="title">ICommand</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">bool</span> <span class="title">CanExecute</span>(<span class="params"><span class="built_in">object</span> parameter</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">// When to execute</span></span><br><span class="line">      <span class="comment">// Validation logic goes here</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">event</span> EventHandler CanExecuteChanged;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Execute</span>(<span class="params"><span class="built_in">object</span> parameter</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// What to Execute</span></span><br><span class="line">        <span class="comment">// Execution logic goes here</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在所有的动作调用都发送到command类，然后被路由到ViewModel类。换句话说，command类需要组合ViewModel类（译注：command类需要一个ViewModel类的引用）。</p><p><img src="https://www.codeproject.com/KB/WPF/819294/15.png" alt="Route"></p><p>下面是简短的代码片段，有四点需要注意：</p><ol><li>ViewModel对象是作为一个私有的成员对象。</li><li>该ViewModel对象将通过构造函数参数的方式传递进来。</li><li>目前为止，我们没有在“CanExecute”中添加验证逻辑，它始终返回true。</li><li>在“Execute”方法中我们调用了ViewModel类的“Calculate”方法。</li></ol><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ButtonCommand</span> : <span class="title">ICommand</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> CustomerViewModel obj; <span class="comment">// Point 1</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ButtonCommand</span>(<span class="params">CustomerViewModel _obj</span>) <span class="comment">// Point 2</span></span></span><br><span class="line">    &#123;</span><br><span class="line">        obj = _obj;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">bool</span> <span class="title">CanExecute</span>(<span class="params"><span class="built_in">object</span> parameter</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// Point 3</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Execute</span>(<span class="params"><span class="built_in">object</span> parameter</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        obj.Calculate(); <span class="comment">// Point 4</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的command代码中，ViewModel对象是通过构造函数传递进来。所以ViewModel类需要创建一个command对象来暴露这个对象的“ICommand”接口。这个“ICommand”接口将被WPF XAML使用并调用。下面是一些关于“CustomerViewModel”类使用command类的要点：</p><ol><li>command类是“CustomerViewModel”类的私有成员。</li><li>在“CustomerViewModel”类的构造函数中将当前对象的实例传递给command类。在之前解释command类的一节中我们说了command类构造函数获取ViewModel类的实例。因此在这一节中我们正是将当前实例传递给command类。</li><li>command对象是通过以“ICommand”接口的形式暴露出来，这样才可以被XAML所使用。</li></ol><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.ComponentModel;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">CustomerViewModel</span></span><br><span class="line">&#123;</span><br><span class="line">    …</span><br><span class="line">    …</span><br><span class="line">    <span class="keyword">private</span> ButtonCommand objCommand; <span class="comment">//  Point 1</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CustomerViewModel</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        objCommand = <span class="keyword">new</span> ButtonCommand(<span class="keyword">this</span>); <span class="comment">// Point 2</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> ICommand btnClick <span class="comment">// Point 3</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> objCommand;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    …</span><br><span class="line">    …</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在你的UI中添加一个按钮，这样就可以把按钮的执行动作连接到暴露的“ICommand”接口。现在打开button的属性栏，选择command属性，右击创建一个数据绑定。</p><p><img src="https://www.codeproject.com/KB/WPF/819294/16.png" alt="Button Property"></p><p>然后选择静态资源（Static Resource），并将“ButtonCommand”附加到button上。</p><p><img src="https://www.codeproject.com/KB/WPF/819294/17.png" alt="Command Binding"></p><p>当你点击了Calculate Tax按钮，它就执行了“CalculateTax”方法。并将税值结果存在“_tax”变量中。关于“CalculateTax”方法代码，可以阅读前面的小节“第三步：添加执行动作和“INotifyPropertyChanged”接口”。</p><p>换句话说，税值计算过程并不会自动通知给UI。所以我们需要从对象发送某种通知给UI，告诉它税值已经变化了，UI需要重新载入绑定值。</p><p><img src="https://www.codeproject.com/KB/WPF/819294/18.png" alt="Notification"></p><p>因此，在ViewModel类中我们需要发送INotify事件给视图。</p><p><img src="https://www.codeproject.com/KB/WPF/819294/19.png" alt="Notification"></p><p>为了让你的ViewModel类能够实现通知，我们必须做三件事情。这三件事情都在下面的代码注释中指出，例如Point1， Point2 和 Point3。</p><p>Point1： 如下面代码那样实现“INotifyPropertyChanged”接口。一旦你实现了该接口，它就创建了对象的“PropertyChangedEventHandler”事件。</p><p>Point2和3： 在“Calculate”方法中用“PropertyChanged”对象去触发事件，并在其中指定了某个属性的通知。在这里是“Tax”属性。安全起见，我们同样也要检查“PropertyChanged”是否不为空。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">CustomerViewModel</span> : <span class="title">INotifyPropertyChanged</span> <span class="comment">// Point 1</span></span><br><span class="line">&#123;</span><br><span class="line">    ….</span><br><span class="line">    ….</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Calculate</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        obj.CalculateTax();</span><br><span class="line">        <span class="keyword">if</span> (PropertyChanged != <span class="literal">null</span>) <span class="comment">// Point 2</span></span><br><span class="line">        &#123;</span><br><span class="line">            PropertyChanged(<span class="keyword">this</span>,<span class="keyword">new</span> PropertyChangedEventArgs(<span class="string">&quot;Tax&quot;</span>));</span><br><span class="line">        <span class="comment">// Point 3</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">event</span> PropertyChangedEventHandler PropertyChanged;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果你运行程序，你应该可以看见当点击按钮后“Tax”值被更新了。</p><h3 id="第四步：在ViewModel中解耦执行动作"><a href="#第四步：在ViewModel中解耦执行动作" class="headerlink" title="第四步：在ViewModel中解耦执行动作"></a>第四步：在ViewModel中解耦执行动作</h3><p>到目前为止，我们用MVVM框架创建了一个简单的界面。这个界面同时包含了属性和命令实现。我们拥有了一个视图，它的UI输入元素（例如textbox）通过绑定和ViewModel连接起来，它的任何执行动作（例如按钮点击）通过命令和ViewModel连接起来。ViewModel和内部的Model通讯。</p><p><img src="https://www.codeproject.com/KB/WPF/819294/20.png" alt="Simple MVVM"></p><p>但是在上面的结构中还有一个问题：command类和ViewModel类存在着过度耦合的情况。如果你还记得command类代码（我在下面贴出来了）中的构造函数是传递了ViewModel对象，这意味着这个command类无法被其它的ViewModel类所复用。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ButtonCommand</span> : <span class="title">ICommand</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> CustomerViewModel obj; <span class="comment">// Point 1</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ButtonCommand</span>(<span class="params">CustomerViewModel _obj</span>) <span class="comment">// Point 2</span></span></span><br><span class="line">    &#123;</span><br><span class="line">        obj = _obj;</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">    ......</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://www.codeproject.com/KB/WPF/819294/21.png" alt="More Actions"></p><p>但是在考虑了所有情况之后，让我们逻辑地思考下“什么是一个动作？”。它是一个事件，可以由用户从鼠标点击（左键或右键），按钮点击，菜单点击，功能键按下等。所以应该有一种方式通用化这些动作，并且让各种ViewModel有一种更通用的方法去绑定它。</p><p>逻辑上讲，如果你认为任务动作是一些方法和函数的封装逻辑。那有什么是“方法”和“函数”的通用表达方式呢？……努力想想…….再想想…….“委托”，“委托”，没错，还是“委托”。</p><p>我们需要两个委托，一个给“CanExecute”，另一个给“Execute”。“CanExecute”返回一个布尔值用来验证以及根据验证来使能（Enable）或者禁用（Disable）用户界面。“Execute”委托则将在“CanExecute”委托返回true时执行。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ButtonCommand</span> : <span class="title">ICommand</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">bool</span> <span class="title">CanExecute</span>(<span class="params"><span class="built_in">object</span> parameter</span>) <span class="comment">// Validations</span></span></span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Execute</span>(<span class="params"><span class="built_in">object</span> parameter</span>) <span class="comment">// Executions</span></span></span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因此，换句话说，我们需要两个委托，一个返回布尔值，另一个执行动作并返回空。所以，创建一个“Func”和一个“Action”如何？“Func”和“Action”都可以用来创建委托。</p><p>如果你还不熟悉Func和Action，可以看下下面这个视频。<br>（译注：作者在这里提供了一个YouTube的视频链接，大概说的就是C#中Func&lt;&gt;和Action&lt;&gt;这两个委托的区别，前者Func&lt;&gt;模版参数包含返回值类型，而Action&lt;&gt;表示无返回值的泛型委托，参见<a target="_blank" rel="noopener" href="https://www.cnblogs.com/akwwl/p/3232679.html">这里</a>）</p><p>通过使用委托的方法，我们试着创建一个通用的command类。我们对command类做了三个修改（代码参见下面），同时我也标注了三点Point 1，2和3。</p><p>Point1： 我们在构造函数中移除了ViewModel对象，改为接受两个委托，一个是“Func”，另一个是“Action”。“Func”委托用作验证（例如验证何时动作将被执行），而“Action”委托用来执行动作。两个委托都是通过构造函数参数传递进来，并赋值给类内部的对应私有成员变量。</p><p>Point2和3： Func&lt;&gt;委托（WhentoExecute）被“CanExecute”调用，执行动作的委托Whattoexecute则是在“Execute”中被调用。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ButtonCommand</span> : <span class="title">ICommand</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">private</span> Action WhattoExecute;</span><br><span class="line">   <span class="keyword">private</span> Func&lt;<span class="built_in">bool</span>&gt; WhentoExecute;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ButtonCommand</span>(<span class="params">Action What , Func&lt;<span class="built_in">bool</span>&gt; When</span>) <span class="comment">// Point 1</span></span></span><br><span class="line">    &#123;</span><br><span class="line">        WhattoExecute = What;</span><br><span class="line">        WhentoExecute = When;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">bool</span> <span class="title">CanExecute</span>(<span class="params"><span class="built_in">object</span> parameter</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> WhentoExecute(); <span class="comment">// Point 2</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Execute</span>(<span class="params"><span class="built_in">object</span> parameter</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        WhattoExecute(); <span class="comment">// Point 3</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们已经知道要执行什么了（例如“CalculateTax”），我们也创建一个简单的函数“IsValid”来验证“Customer”类是否有效。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Customer</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">CalculateTax</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (_Amount &gt; <span class="number">2000</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                _Tax = <span class="number">20</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (_Amount &gt; <span class="number">1000</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                _Tax = <span class="number">10</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                _Tax = <span class="number">5</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">bool</span> <span class="title">IsValid</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (_Amount == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在ViewModel类中我们同时传递函数和方法给command类的构造函数，一个给“Func”，一个给“Action”。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">CustomerViewModel</span> : <span class="title">INotifyPropertyChanged</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span> Customer obj = <span class="keyword">new</span> Customer();</span><br><span class="line">privateButtonCommandobjCommand;</span><br><span class="line">publicCustomerViewModel()</span><br><span class="line">        &#123;</span><br><span class="line">objCommand = <span class="keyword">new</span> ButtonCommand(obj.CalculateTax,</span><br><span class="line">obj.IsValid);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样使得框架更好，更解耦， 使得这个command类可以以一个通用的方式被其它ViewModel引用。下面是改善后的架构， 需要注意ViewModel如何通过委托（Func和Action）和command类交互。</p><p><img src="https://www.codeproject.com/KB/WPF/819294/22.png" alt="Final architecture"></p><h3 id="第五步：利用PRISM"><a href="#第五步：利用PRISM" class="headerlink" title="第五步：利用PRISM"></a>第五步：利用PRISM</h3><p>最后如果有一个框架能帮助实现我们的MVVM代码那就更好了。PRISM就是其中一个可复用的框架。PRISM的主要用途是为了提供模块化开发，但是它提供了一个很好的“DelegateCommand”类拿来代替我们自己创建的command类。</p><p>所以，第一件事情就是从<a target="_blank" rel="noopener" href="https://www.microsoft.com/en-in/download/details.aspx?id=42537">这里</a>下载PRISM，编译这个解决方案，添加“Microsoft.Practices.Prism.Mvvm.dll”和“Microsoft.Practices.Prism.SharedInterfaces.dll”这两个DLL库的引用。</p><p>你可以去掉自定义的command类，导入“Microsoft.Practices.Prism.Commands”名称空间， 然后以下面代码的方式使用DelegateCommand。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">CustomerViewModel</span> : <span class="title">INotifyPropertyChanged</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> Customer obj = <span class="keyword">new</span> Customer();</span><br><span class="line">    <span class="keyword">private</span> DelegateCommand  objCommand;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CustomerViewModel</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        objCommand = <span class="keyword">new</span> DelegateCommand(obj.CalculateTax, obj.IsValid);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    ...</span><br><span class="line">    ...</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="WPF-MVVM的视频演示"><a href="#WPF-MVVM的视频演示" class="headerlink" title="WPF MVVM的视频演示"></a>WPF MVVM的视频演示</h3><p>我同时也在下面的视频中从头演示了如何实现WPF MVVM（译注：一个YouTube链接…）。</p><p><a target="_blank" rel="noopener" href="https://www.youtube.com/watch?v=z5t90kvagTw"><img src="https://www.codeproject.com/KB/WPF/819294/video_2.png" alt="IMAGE ALT TEXT"></a></p><h3 id="延伸阅读"><a href="#延伸阅读" class="headerlink" title="延伸阅读"></a>延伸阅读</h3><ol><li><a target="_blank" rel="noopener" href="https://www.codeproject.com/Articles/165368/WPF-MVVM-Quick-Start-Tutorial">WPF&#x2F;MVVM Quick Start Tutorial</a></li><li><a target="_blank" rel="noopener" href="https://www.codeproject.com/Articles/26288/Simplifying-the-WPF-TreeView-by-Using-the-ViewMode">Simplifying the WPF TreeView by Using the ViewModel Pattern</a></li><li><a target="_blank" rel="noopener" href="https://msdn.microsoft.com/zh-cn/magazine/dn630646.aspx">MVVM 应用程序中的多线程与调度</a></li><li><a target="_blank" rel="noopener" href="https://msdn.microsoft.com/magazine/dn605875">针对异步 MVVM 应用程序的模式：数据绑定</a></li><li><a target="_blank" rel="noopener" href="https://msdn.microsoft.com/zh-cn/magazine/dn630647.aspx">针对异步 MVVM 应用程序的模式：命令</a></li><li><a target="_blank" rel="noopener" href="https://blog.magnusmontin.net/2014/01/30/wpf-using-behaviours-to-bind-to-readonly-properties-in-mvvm/">Using behaviours to bind to read-only properties in MVVM</a></li><li><a target="_blank" rel="noopener" href="https://blog.magnusmontin.net/2013/06/17/cascading-comboboxes-in-wpf-using-mvvm/">Cascading ComboBoxes in WPF using MVVM</a></li><li><a target="_blank" rel="noopener" href="https://social.technet.microsoft.com/wiki/contents/articles/18821.wpfmvvm-binding-the-ischecked-property-of-a-checkbox-to-several-other-checkboxes.aspx">WPF&#x2F;MVVM: Binding the IsChecked Property of a CheckBox to Several Other CheckBoxes</a></li></ol></div><div class="article-footer"></div></article><section id="comments"></section></div><nav class="bar bar-footer clearfix" data-stick-bottom><div class="bar-inner"><ul class="pager pull-left"><li class="prev"><a href="/2016/01/13/For%20%E5%B8%95%E5%B0%94%E5%93%88%E6%8F%90/" title="For 帕尔哈提"><i class="icon icon-angle-left" aria-hidden="true"></i><span>&nbsp;&nbsp;上一篇</span></a></li><li class="next"><a href="/2015/10/01/Python3%E4%B8%8BDjango%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E4%B8%8E%E6%B7%BB%E5%8A%A0MySQL%E6%94%AF%E6%8C%81/" title="Python3下Django环境搭建与添加MySQL支持"><span>下一篇&nbsp;&nbsp;</span><i class="icon icon-angle-right" aria-hidden="true"></i></a></li></ul><div class="bar-right"></div></div></nav></main><footer class="footer" itemscope itemtype="http://schema.org/WPFooter"><ul class="social-links"><li><a href="https://github.com/unpluggedcoder" target="_blank" title="Github" data-toggle="tooltip" data-placement="top"><i class="icon icon-github"></i></a></li><li><a href="https://twitter.com/unpluggedcoder" target="_blank" title="Twitter" data-toggle="tooltip" data-placement="top"><i class="icon icon-twitter"></i></a></li><li><a href="/atom.xml" target="_blank" title="Rss" data-toggle="tooltip" data-placement="top"><i class="icon icon-rss"></i></a></li></ul><div class="copyright">&copy; 2022 不插电码农<div class="publishby">Theme by <a href="https://github.com/cofess" target="_blank">cofess </a>base on <a href="https://github.com/cofess/hexo-theme-pure" target="_blank">pure</a>.</div></div></footer><script src="//cdn.jsdelivr.net/npm/jquery@1.12.4/dist/jquery.min.js"></script><script>window.jQuery||document.write('<script src="js/jquery.min.js"><\/script>')</script><script src="/js/plugin.min.js"></script><script src="/js/application.js"></script><script>window.INSIGHT_CONFIG={TRANSLATION:{POSTS:"文章",PAGES:"页面",CATEGORIES:"分类",TAGS:"标签",UNTITLED:"(未命名)"},ROOT_URL:"/",CONTENT_URL:"/content.json"}</script><script src="/js/insight.js"></script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="//cdn.jsdelivr.net/npm/gitment@0.0.3/dist/gitment.browser.min.js"></script><script>var gitment=new Gitment({id:"[译] WPF MVVM 循序渐进(从基础到高级)",owner:"unpluggedcoder",repo:"git@github.com:unpluggedcoder/unpluggedcoder.github.io.git",oauth:{client_id:"fa8b1da7bafdb9a3da0a",client_secret:"a915ab939d522b615beec4e26df304dce21c4e8e"}});gitment.render("comments")</script><script src="//cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.3.5/dist/jquery.fancybox.min.js"></script><script>$(document).ready(function(){$("article img").not("[hidden]").not(".panel-body img").each(function(){var a,t,n=$(this),e=n.attr("alt"),r=n.parent("a");r.length<1&&(-1!=(t=(a=this.getAttribute("src")).lastIndexOf("?"))&&(a=a.substring(0,t)),r=n.wrap('<a href="'+a+'"></a>').parent("a")),r.attr("data-fancybox","images"),e&&r.attr("data-caption",e)}),$().fancybox({selector:'[data-fancybox="images"]',hash:!1,loop:!1})})</script><script defer type="text/javascript">!function(e,a,t,n,g,c){e.GoogleAnalyticsObject=n,e.ga=e.ga||function(){(e.ga.q=e.ga.q||[]).push(arguments)},e.ga.l=+new Date,g=a.createElement(t),c=a.getElementsByTagName(t)[0],g.async=1,g.src="//www.google-analytics.com/analytics.js",c.parentNode.insertBefore(g,c)}(window,document,"script","ga"),ga("create","UA-99016428-2","auto"),ga("send","pageview")</script></body></html>